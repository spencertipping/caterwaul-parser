// Caterwaul parser combinators | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This is a generalization of parser combinators onto nonlinear data structures such as trees or graphs (though it also works with strings). The idea is that a location within a data structure
// doesn't have to be scalar, though it generally would be when parsing text. In order to define a combinatory parser over a structure, you need to do a few things:

// | 1. Construct a memoization key. This is a function from the input position to a string.
//   2. Provide parser combinators that return new states. Most of the higher-order combinators are general that they will work with low-level combinators.
//   3. Provide a function that constructs the initial location given an input. For strings, this is just f(s) = 0.

// Because this parser combinator library implements a non-backtracking Packrat parser, the usual nondeterminism caveats apply.

// Implementation specifics.
// Unlike some parser combinator implementations, this one provides a way to specify detailed failure information. This gives the user an idea about why and where a parse failed. Also unlike many
// Javascript parser combinator libraries, this one uses Caterwaul macros to make it easy to build up grammars. Each operator corresponds to a higher-order combinator provided by the Caterwaul
// parsing library.
// Generated by SDoc 
