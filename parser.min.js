caterwaul.js_all()(function(a){a.parser=capture[annotate=annotate,parsers=parsers],a.parser/-a.merge/wcapture[bfs(ps=parsers("bfs",arguments),annotate(result,"bfs",ps))(states)=ps/[states][x/-memo/x0]-seq,bfc(ps=parsers("bfc",arguments),annotate(result,"bfc",ps))(states)=ps/[states/!state_matrix][step_matrix_mutable(x)(x0)]/seq/!row_composite_states_from,state_matrix(states)=states*[[x]]-seq,step_matrix_mutable(p)(m)=m*~!r[xs.length===1?r.push(xs[0])&&[r]:xs*~[r+[x]]-seq,where[xs=p/-memo_single/r[r.length-1]]]-seq,step_matrix_immutable(p)(m)=m*~!~r[memo_single(p,r[r.length-1])*~[r+[x]]]-seq,row_composite_states_from(m)=m*r[r[r.length-1].map("r.slice(1, r.length) *[x.value()] -seq".qf)]-seq,alt(ps=parsers("alt",arguments),annotate(result,"alt",ps))(states)=states*~!state[ps|p[p/-memo_single/state-re[it.length&&it]]|seq||[]]-seq,all(ps=parsers("all",arguments),annotate(result,"all",ps))(states)=states*~!~state[ps*~!p[p/-memo_single/state]]-seq,manyc(p,annotate(result,"manyc",[p]))(states)=state_matrix(states)/~!step/seq/!row_null_states_from-where[iterate=step_matrix_mutable_null(p),step(m)=has_non_null_states(m)?iterate(m):null],manyc_one(p)=p/-bfc/manyc(p)/-map/"[_[0]] + _[1] -seq".qf,many(p,join,annotate(result,"many",[p,join]))=f-where[j=join||bfs,f(states)=f(states),f=p/-j/annotate(f,"recursive",[])/-alt/p],optional(p,annotate(result,"optional",[p]))=p/-alt/zero(),step_matrix_immutable_null(p)(m)=m*~!r[xs?xs.length?xs*~[r+[x]]-seq:[r+[null]-seq]:[r],where[xs=r[r.length-1]-re[it&&p/-memo_single/it]]]-seq,step_matrix_mutable_null(p)(m)=m*~!r[xs?l?l===1?r.push(xs[0])&&[r]:xs*~[r+[x]]-seq:r.push(null)&&[r]:[r],where[xs=r[r.length-1]-re[it&&p/-memo_single/it],l=xs&&xs.length]]-seq,has_non_null_states(m)=m|r[r[r.length-1]]|seq,row_null_states_from(ms)=ms[ms.length-1]*r[r[r.length-2].map("r.slice(1, r.length - 1) *[x.value()] -seq".qf)]/seq,zero(annotate(result,"zero",[]))(states)=states,fail(annotate(result,"fail",[]))(states)=[],match(p,annotate(result,"match",[p]))(states)=states%[memo_single(p,x).length]-seq,reject(p,annotate(result,"reject",[p]))(states)=states%![memo_single(p,x).length]-seq,pluralize(p,annotate(result,"pluralize",[p]))(states)=states%~!p-seq,iv(f,annotate(result,"iv",[f]))(states)=states*[x.change({value:f(x.input(),x.position())})]-seq,map(p,f,annotate(result,"map",[p,f]))(states)=p(states)*[x.map(f)]-seq,flat_map(p,f,annotate(result,"flat_map",[p,f]))(states)=p(states)*~!~[f(x.value())*y[x.map(delay in y)]]-seq,map_state(p,f,annotate(result,"map_state",[p,f]))(states)=p(states)*[f(x)]-seq,flat_map_state(p,f,annotate(result,"flat_map_state",[p,f]))(states)=p(states)*~![f(x)]-seq],a.parser.logical_state(options)=ctor-se-it.prototype/-a.merge/methods_for(options.step)-where[defaults=options.defaults||{},default_position=defaults.position,default_value=defaults.value,id_function=defaults.id||"++memo_id".qf,ctor(i,p,v,memo_table)=arguments.length>1?this-se[it.i=i,it.p=p,it.v=v,it.table=memo_table]:this-se[it.i=i,it.p=default_position,it.v=default_value,it.table={}],methods_for(step)=capture[id()=this.cached_id||(this.cached_id=id_function.call(this)),input()=this.i,next(n,v)=n===1?step.call(this,this.p,v):this.next(n-1,v)*~![x.next(1,v)]-seq,position()=this.p,map(f)=new this.constructor(this.i,this.p,this.v/!f,this.table),value()=this.v,memo_table()=this.table,toString()="#{this.i} @ #{this.p} : #{this.v}",change(values)=new this.constructor("input" in values?values.input:this.i,"position" in values?values.position:this.p,"value" in values?values.value:this.v,this.table)]],a.parser.linear_string_state=capture[step(p,v)=[this.change({position:p+1,value:v})],id()=this.position(),defaults={position:0}]/!a.parser.logical_state/-a.merge/capture[end(annotate(result,"end",[]))(states)=states%[x.position()===x.input().length]-seq],a.merge(a.parser,capture[anchor_regexp(r)=new RegExp("^#{body}$",flags)-where[pieces=/^\/(.*)\/(\w*)$/.exec(r.toString()),body=pieces[1],flags=pieces[2]],linear_string(s,annotate(result,"linear_string",[s]))(states)=states*~![x.input().substr(x.position(),s.length)===s?x.next(s.length,s):[]]-seq,linear_regexp(r,annotate(result,"linear_regexp",[r]))=matcher-where[minimum_length=a.regexp(r).minimum_length()||raise[new Error("regexp must require at least one character: #{r}")],anchored=r/!a.parser.anchor_regexp,matcher(states)=states*~!match_one-seq,match_one(state)=new_states-where[s=state.input(),offset=state.position(),maximum_length=s.length-offset,match(l)=l<=maximum_length&&anchored.test(s.substr(offset,l)),longest(l)=l/!match?longest(l<<1):l,valid(l,m,u)=l<u-1?m/!match?valid(m,m+u>>1,u):valid(l,l+m>>1,m):m,new_states=minimum_length/!match?state.next(match_length,anchored.exec(s.substr(offset,match_length)))-where[max=minimum_length/!longest,match_length=valid(minimum_length,minimum_length+max>>1,max)]:[]]]]),a.parser.structure_state=capture[step(p,v)=this.input()/pairs*[this.change({value:v,input:x[1],position:x[0]})]-seq]/!a.parser.logical_state,a.parser.array_state=capture[step(p,v)=+this.input()*[this.change({value:v,input:x,position:xi})]-seq]/!a.parser.logical_state,(a.parser.proxy_state(s,value_function)=this-se[it.state=s,it.value_function=value_function]).prototype/-a.merge/capture[id()=this.cached_id||(this.cached_id=++memo_id),input()=this.value_function.call(this),next(n,v)=this.state.next(n,v),position()=this.state.position(),map(f)=this.state.map(f),value()=this.state.value(),memo_table()=this.state.memo_table()],a.parser/-a.merge/capture[position_state(s)=new a.parser.proxy_state(s,"this.position()".qf),position(p)(states)=p(states*a.parser.position_state-seq)],where[memoization_key=a.gensym("memo"),memo_id=0,memo_single(f,state)=value-where[f_key=f[memoization_key]||(f[memoization_key]=++memo_id),s_key=state.id(),table=state.memo_table(),key="@#{s_key}_#{f_key}",value=f_key&&s_key&&table.hasOwnProperty(key)?table[key]:(table[key]=f([state]))],memo(f,states)=states*~![f/-memo_single/x]-seq,parsers(name,xs)=+xs*![x||raise[new Error("#{name}: undefined parser given as parameter #{xi}")]]*~![x instanceof Array?x:[x]]*![x.caterwaul_parser||raise[new Error("#{name}: #{x} is not marked with the .caterwaul_parser attribute")]]-seq,annotate(f,name,xs)=f-se[xs=xs||[],it.toString()='#{name}(#{xs *[x.toString()] -seq -re- it.join(", ")})',it.caterwaul_parser=true]]})(caterwaul);